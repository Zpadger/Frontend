## ['1', '2', '3'].map(parseInt)详解 

### 需求背景  
在前端开发过程中，因为弱类型的关系，所以在对接的过程中，需要将**string**等其他类型转换为**int**。  


### 一个简单的问题    

以下代码输出是什么？

>['1', '2', '3'].map(parseInt)

答案是：  
>[1, NaN, NaN]


### 知识点讲解
**1.** parseInt语法  
>parseInt(string, radix); 

#### string
要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  ToString 抽象操作)。字符串开头的空白符将会被忽略。


#### radix
一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的**基数**。比如参数"10"表示使用我们通常使用的十进制数值系统。**始终指定此参数**可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值**默认为10**。


**2.** map 函数等价于  
>['1', '2', '3'].map((string, index) => return parseInt(string, index)) 


**3.** 返回值  
返回一个整数或NaN


**4.** 规约1  
如果**parseInt**遇到了不属于**radix**参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。**parseInt**将截取整数部分。开头和结尾的空白符允许存在，会被忽略。


**5.** 规约2  
在基数为**undefined**，或者基数为**0**或者没有指定的情况下，JavaScript 作如下处理：  
* 如果字符串**string**以"0x"或者"0X"开头, 则基数是**16 (16进制)** 。 
* 如果字符串**string**以"0"开头, 基数是**8（八进制）或者10（十进制）**，那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，**永远都要明确给出radix参数的值**。  
* 如果字符串**string**以其它任何值开头，则基数是**10 (十进制)**。  
如果第一个字符不能被转换成数字，**parseInt**返回**NaN**。


### 例题详解
**例一**  
>['1', '2', '3'].map(parseInt)  
//答案  
[1, NaN, NaN]

**解析**  
>// 答案解析  
['1', '2', '3'].map((string, index) => return parseInt(string, index)) === [parseInt('1', 0), parseInt('2', 1), parseInt('3', 2)]  

parseInt('1', 0) 按照 知识点5(规约2)，等价于 parseInt('1', 10) 等价于 parseInt('1', undefined) 等价于 parseInt('1') === 1 

parseInt('2', 1) 按照 知识点1(语法) 发现不满足radius在2~36之间，那么按照 知识点5(规约2)，匹配不到任何一种情况，按照知识点2，无法返回整数，那么就只能返回NaN  

parseInt('3', 2) 按照 知识点1（语法）发现，2代表二进制数，那么应该将'3'解析开始按照二进制进行解析，但是在二进制中，只能识别0和1,3是无法被识别的，所以返回NaN



### 例子  
* 相关练习：  
>var name = "window";  
function showName(){  
&emsp;&emsp;console.log(this.name);  
}  
var person1 = {  
&emsp;&emsp;name: "kxy",  
&emsp;&emsp;sayName: showName  
}  
var person2 = {  
&emsp;&emsp;name: "Jake",  
&emsp;&emsp;sayName: function(){  
&emsp;&emsp;&emsp;&emsp;var fun = person1.sayName;  
&emsp;&emsp;&emsp;&emsp;fun();  
&emsp;&emsp;}  
}  
person1.sayName();&emsp;&emsp;//kxy  
person2.sayName();&emsp;&emsp;//window  

首先时刻提醒自己this是在函数执行时被绑定的，不要被赋值语句扰乱。  
先看第一个执行语句：person1.sayName();这是方法调用模式，对象为person1，再看sayName被赋值为全局函数对象showName，在showName执行时，this绑定的
是person1，所以结果是"kxy"。  

再看第二个执行语句：person2.sayName(); 这还是方法调用模式，对象为person2，调用的是它的sayName方法。再看sayName函数体，发现函数体最终执行的函数是fun，fun是用函数调用模式调用的。而fun最终也被赋值为showName函数，因为fun是用函数调用模式调用的，所以这里的this绑定为window，结果为”window“。

